<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="UTF-8">
  <title>StarLights</title>
  		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
			.label {
				color: #F00;
				font-family: sans-serif;
				padding: 2px;
				background: rgba( 0, 0, 0, .6 );
			}
		</style>
</head>
<body>
<script src='https://threejs.org/build/three.min.js'></script>
<script src='https://cdn.rawgit.com/mrdoob/three.js/master/examples/js/controls/OrbitControls.js'></script>
<script src='https://cdn.rawgit.com/mrdoob/three.js/master/examples/js/renderers/CSS2DRenderer.js'></script>
<script src='https://cdn.jsdelivr.net/npm/animejs@3.0.0/lib/anime.min.js'></script>
<script src='js/Stats.js'></script>


<script type="text/javascript">
	var scene = new THREE.Scene();
	var camera = new THREE.PerspectiveCamera( 85, window.innerWidth/window.innerHeight, 1, 2000);

	//
	// WebGL Renderer
	var renderer = new THREE.WebGLRenderer();
		renderer.setSize( window.innerWidth, window.innerHeight );
	document.body.appendChild( renderer.domElement );
	
	//
	// CSS 2D Renderer
	var labelRenderer = new THREE.CSS2DRenderer();
		labelRenderer.setSize( window.innerWidth, window.innerHeight );
		labelRenderer.domElement.style.position = 'absolute';
		labelRenderer.domElement.style.top = 0;
	document.body.appendChild( labelRenderer.domElement );
	
	//
	// Lights
	var light = new THREE.HemisphereLight( 0xffffff, 0x080820, 4 );
	scene.add( light );
	// var ambientLight = new THREE.AmbientLight(0xf1f1f1);
	// scene.add(ambientLight);
	// var spotLight = new THREE.DirectionalLight(0xffffff);
	// spotLight.position.set(50,50,50);
	// scene.add(spotLight);


	camera.position.z = 50; //is orginial cameria setting.
	//see screenshots for overview position reference
	      //Lights

	      //Starfield
	var starGeometry = new THREE.SphereGeometry(1000, 50, 50);
	var starMaterial = new THREE.MeshPhongMaterial({
	  //map: new THREE.ImageUtils.loadTexture("/textures/galaxy_starfield.png"),
	  map: new THREE.ImageUtils.loadTexture("/textures/starmap.jpg"),
	  color: 0x000000,
	  side: THREE.DoubleSide,
	  shininess: 0
	});
	var starField = new THREE.Mesh(starGeometry, starMaterial);
	scene.add(starField);


	var controls = new THREE.OrbitControls( camera, labelRenderer.domElement );
	controls.maxDistance = 500;

	controls.update();

	var starCount = 300;

	for (var i = 0; i < starCount; i++) {

	var particleSize = Math.random() * 1 -.3;

	var geometry = new THREE.SphereGeometry( particleSize, 32, 32 );
	var material = new THREE.MeshBasicMaterial( {color: 0xffffff} ); //white
	//var material = new THREE.MeshBasicMaterial( {color: 0xffff00} ); // yellow
	var sphere = new THREE.Mesh( geometry, material );
	sphere.position.x = Math.random() * 500 - 250;
	sphere.position.y = Math.random() * 500 - 250;
	sphere.position.z = Math.random() * 500 - 250;
	scene.add( sphere );

	}

	var blueCount = 100;

	for (var i = 0; i < blueCount; i++) {

	var particleSize = Math.random() * 1 -.3;

	var geometry = new THREE.SphereGeometry( particleSize, 32, 32 );
	var material = new THREE.MeshBasicMaterial( {color: 0x23e57a3} ); //white
	//var material = new THREE.MeshBasicMaterial( {color: 0xffff00} ); // yellow
	var sphere = new THREE.Mesh( geometry, material );
	sphere.position.x = Math.random() * 500 - 250;
	sphere.position.y = Math.random() * 500 - 250;
	sphere.position.z = Math.random() * 500 - 250;
	scene.add( sphere );

	}
	
	
	
	
	
	
	//
	// SIMLUATION OF LOADED JSON DATA
	var json = {
	    "constellation": {
			"stars": [
				{"x":0, "y":0, "z":50, "connected":1, "labelposition":"b", "label":"GREETINGS"},
				{"x":50, "y":50, "z":0, "connected":1, "labelposition":"t", "label":"PROFESSOR"},
				{"x":100, "y":0, "z":50, "connected":0, "labelposition":"l", "label":"FALKEN!"},
				{"x":150, "y":50, "z":0, "connected":1, "labelposition":"r", "label":"HOW"},
				{"x":-50, "y":50, "z":150, "connected":1, "labelposition":"r", "label":"ABOUT"},
				{"x":-150, "y":0, "z":250, "connected":1, "labelposition":"r", "label":"A"},
				{"x":-200, "y":100, "z":450, "connected":1, "labelposition":"r", "label":"NICE"},
				{"x":0, "y":150, "z":550, "connected":1, "labelposition":"r", "label":"GAME"},
				{"x":50, "y":-50, "z":750, "connected":1, "labelposition":"r", "label":"OF"},
				{"x":150, "y":0, "z":850, "connected":1, "labelposition":"r", "label":"CHESS?"}
		    ]        
	    }
	}
	
	var figure = new THREE.Geometry();
	
	for(var i = 0; i < json.constellation.stars.length; i++) {
    	var obj = json.constellation.stars[i];
		console.log(obj.label);
			
		var vector = new THREE.Vector3(obj.x, obj.y, obj.z);
		figure.vertices.push(vector);
		
		var label_div = document.createElement( 'div' );
			label_div.className = 'label';
			label_div.textContent = obj.label;
			label_div.style.marginTop = '-1em';
			
		var label_2d = new THREE.CSS2DObject( label_div );
			label_2d.position.set( 0, 5, 0 );
			
		var geometry = new THREE.SphereGeometry( 0.0001, 1, 1 );
		var material = new THREE.MeshBasicMaterial( {color: 0x000000, transparent:true, opacity:0} );
		var sphere = new THREE.Mesh( geometry, material );
			sphere.position.x = obj.x;
			sphere.position.y = obj.y;
			sphere.position.z = obj.z;	
			sphere.add( label_2d );
		
		scene.add(sphere);		
		
		
				
		//
		// BASIC STAR SPRITES
		var point_material = new THREE.PointsMaterial( { size: 3, color:0xff0000, depthTest: false, transparent: true } );
		var anchor = new THREE.Points(figure, point_material);
		scene.add(anchor);		
			
						
		
	}

	figure.computeBoundingSphere();
	
	var points = figure.vertices;
	var geometry = new THREE.BufferGeometry();
	var fraction = 0;
	var lineLength;

	// attributes
	numPoints = points.length;
	var positions = new Float32Array( numPoints * 3 ); // 3 vertices per point
	var lineDistances = new Float32Array( numPoints * 1 ); // 1 value per point

	geometry.setAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
	geometry.setAttribute( 'lineDistance', new THREE.BufferAttribute( lineDistances, 1 ) );

	// populate

	for ( var i = 0, index = 0, l = numPoints; i < l; i ++, index += 3 ) {

		positions[ index ] = points[ i ].x;
		positions[ index + 1 ] = points[ i ].y;
		positions[ index + 2 ] = points[ i ].z;

		if ( i > 0 ) {

			lineDistances[ i ] = lineDistances[ i - 1 ] + points[ i - 1 ].distanceTo( points[ i ] );

		}

	}

	lineLength = lineDistances[ numPoints - 1 ];

	// material
	var material = new THREE.LineDashedMaterial( {
  	dashSize: 3, // to be updated in the render loop
  	gapSize: 1e10 // a big number, so only one dash is rendered

	} );

	// line
	line = new THREE.Line( geometry, material );
	scene.add( line );


	//
	// WINDOW RESIZE
	window.addEventListener('resize', function () {
		renderer.setSize(window.innerWidth, window.innerHeight);
		labelRenderer.setSize(window.innerWidth, window.innerHeight);
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();
	});	

	//
	// STATS
	var stats = new Stats();
		stats.domElement.style.position = 'absolute';
		stats.domElement.style.top = '0px';
		stats.domElement.style.zIndex = 100;
	
	document.body.appendChild( stats.domElement );	




	//
	// ANIMATION LOOP
	function animate() {
		requestAnimationFrame(animate);
		fraction = ( fraction + 0.001 ) % 100;
		line.material.dashSize = fraction * lineLength;
		render();		
		update();
	}
	function update() {
		controls.update();
		stats.update();
	}
	
	function render() {
		renderer.render( scene, camera );
		labelRenderer.render( scene, camera );
	}

	animate();
	

</script>



</body>
</html>
