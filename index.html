<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="UTF-8">
  <title>StarLights</title>
  		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
</head>
<body>
<script src='https://threejs.org/build/three.min.js'></script>
<script src='https://cdn.rawgit.com/mrdoob/three.js/master/examples/js/controls/OrbitControls.js'></script>
<script src='https://cdn.jsdelivr.net/npm/animejs@3.0.0/lib/anime.min.js'></script>
<script src='js/LegacyJSONLoader.js'></script>
<script src='js/Stats.js'></script>


<script type="text/javascript">
	var scene = new THREE.Scene();
	var camera = new THREE.PerspectiveCamera( 85, window.innerWidth/window.innerHeight, 1, 2000);

	var renderer = new THREE.WebGLRenderer();
	renderer.setSize( window.innerWidth, window.innerHeight );
	document.body.appendChild( renderer.domElement );


	//Lights
	var light = new THREE.HemisphereLight( 0xffffff, 0x080820, 4 );
	scene.add( light );
	// var ambientLight = new THREE.AmbientLight(0xf1f1f1);
	// scene.add(ambientLight);
	// var spotLight = new THREE.DirectionalLight(0xffffff);
	// spotLight.position.set(50,50,50);
	// scene.add(spotLight);


	camera.position.z = 50; //is orginial cameria setting.
	//see screenshots for overview position reference
	      //Lights

	      //Starfield
	var starGeometry = new THREE.SphereGeometry(1000, 50, 50);
	var starMaterial = new THREE.MeshPhongMaterial({
	  //map: new THREE.ImageUtils.loadTexture("/textures/galaxy_starfield.png"),
	  map: new THREE.ImageUtils.loadTexture("/textures/starmap.jpg"),
	  side: THREE.DoubleSide,
	  shininess: 0
	});
	var starField = new THREE.Mesh(starGeometry, starMaterial);
	scene.add(starField);


	var controls = new THREE.OrbitControls( camera, renderer.domElement );
	controls.maxDistance = 500;

	controls.update();

	var starCount = 300;

	for (var i = 0; i < starCount; i++) {

	var particleSize = Math.random() * 1 -.3;

	var geometry = new THREE.SphereGeometry( particleSize, 32, 32 );
	var material = new THREE.MeshBasicMaterial( {color: 0xffffff} ); //white
	//var material = new THREE.MeshBasicMaterial( {color: 0xffff00} ); // yellow
	var sphere = new THREE.Mesh( geometry, material );
	sphere.position.x = Math.random() * 500 - 250;
	sphere.position.y = Math.random() * 500 - 250;
	sphere.position.z = Math.random() * 500 - 250;
	scene.add( sphere );

	}

	var blueCount = 100;

	for (var i = 0; i < blueCount; i++) {

	var particleSize = Math.random() * 1 -.3;

	var geometry = new THREE.SphereGeometry( particleSize, 32, 32 );
	var material = new THREE.MeshBasicMaterial( {color: 0x23e57a3} ); //white
	//var material = new THREE.MeshBasicMaterial( {color: 0xffff00} ); // yellow
	var sphere = new THREE.Mesh( geometry, material );
	sphere.position.x = Math.random() * 500 - 250;
	sphere.position.y = Math.random() * 500 - 250;
	sphere.position.z = Math.random() * 500 - 250;
	scene.add( sphere );

	}

	var figure = new THREE.Geometry();

	figure.vertices.push(
		new THREE.Vector3( 0,  0, 50 ),
		new THREE.Vector3( 50, 50, 0 ),
		new THREE.Vector3( 100, 0, 50 ),
		new THREE.Vector3( 150, 50, 0 ),
	);

	geometry.faces.push( new THREE.Face3( 0, 1, 2 ) );

	figure.computeBoundingSphere();

	var points = figure.vertices;
	var geometry = new THREE.BufferGeometry();
	var fraction = 0;
	var lineLength;

	// attributes
	numPoints = points.length;
	var positions = new Float32Array( numPoints * 3 ); // 3 vertices per point
	var lineDistances = new Float32Array( numPoints * 1 ); // 1 value per point

	geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
	geometry.addAttribute( 'lineDistance', new THREE.BufferAttribute( lineDistances, 1 ) );

	// populate

	for ( var i = 0, index = 0, l = numPoints; i < l; i ++, index += 3 ) {

		positions[ index ] = points[ i ].x;
		positions[ index + 1 ] = points[ i ].y;
		positions[ index + 2 ] = points[ i ].z;

		if ( i > 0 ) {

			lineDistances[ i ] = lineDistances[ i - 1 ] + points[ i - 1 ].distanceTo( points[ i ] );

		}

	}

	lineLength = lineDistances[ numPoints - 1 ];

	// material
	var material = new THREE.LineDashedMaterial( {
  	dashSize: 3, // to be updated in the render loop
  	gapSize: 1e10 // a big number, so only one dash is rendered

	} );

	// line
	line = new THREE.Line( geometry, material );
	scene.add( line );


	//
	// WINDOW RESIZE
	window.addEventListener('resize', function () {
		renderer.setSize(window.innerWidth, window.innerHeight);
		labelRenderer.setSize(window.innerWidth, window.innerHeight);
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();
	});	

	//
	// STATS
	var stats = new Stats();
		stats.domElement.style.position = 'absolute';
		stats.domElement.style.top = '0px';
		stats.domElement.style.zIndex = 100;
	
	document.body.appendChild( stats.domElement );	




	//
	// ANIMATION LOOP
	function animate() {
		requestAnimationFrame(animate);
		fraction = ( fraction + 0.001 ) % 100;
		line.material.dashSize = fraction * lineLength;
		render();		
		update();
	}
	function update() {
		controls.update();
		stats.update();
	}
	
	function render() {
		renderer.render( scene, camera );
	}

	animate();
	

</script>



</body>
</html>
