<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="UTF-8">
  <title>StarLights</title>
  		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
</head>
<body>
<script src='https://threejs.org/build/three.min.js'></script>
<script src='https://cdn.rawgit.com/mrdoob/three.js/master/examples/js/controls/OrbitControls.js'></script>
<script src='https://cdn.jsdelivr.net/npm/animejs@3.0.0/lib/anime.min.js'></script>



<script type="text/javascript">
	var scene = new THREE.Scene();
	var camera = new THREE.PerspectiveCamera( 85, window.innerWidth/window.innerHeight, 1, 2000);

	var renderer = new THREE.WebGLRenderer();
	renderer.setSize( window.innerWidth, window.innerHeight );
	document.body.appendChild( renderer.domElement );


	//Lights
	var light = new THREE.HemisphereLight( 0xffffff, 0x080820, 4 );
	scene.add( light );
	// var ambientLight = new THREE.AmbientLight(0xf1f1f1);
	// scene.add(ambientLight);
	// var spotLight = new THREE.DirectionalLight(0xffffff);
	// spotLight.position.set(50,50,50);
	// scene.add(spotLight);


	camera.position.z = 50; //is orginial cameria setting.
	//see screenshots for overview position reference
	      //Lights

	      //Starfield
	var starGeometry = new THREE.SphereGeometry(1000, 50, 50);
	var starMaterial = new THREE.MeshPhongMaterial({
	  //map: new THREE.ImageUtils.loadTexture("/textures/galaxy_starfield.png"),
	  map: new THREE.ImageUtils.loadTexture("/textures/starmap.jpg"),
	  side: THREE.DoubleSide,
	  shininess: 0
	});
	var starField = new THREE.Mesh(starGeometry, starMaterial);
	scene.add(starField);


	var controls = new THREE.OrbitControls( camera, renderer.domElement );
	controls.maxDistance = 500;

	controls.update();

	var starCount = 300;

	for (var i = 0; i < starCount; i++) {

	var particleSize = Math.random() * 1 -.3;

	var geometry = new THREE.SphereGeometry( particleSize, 32, 32 );
	var material = new THREE.MeshBasicMaterial( {color: 0xffffff} ); //white
	//var material = new THREE.MeshBasicMaterial( {color: 0xffff00} ); // yellow
	var sphere = new THREE.Mesh( geometry, material );
	sphere.position.x = Math.random() * 500 - 250;
	sphere.position.y = Math.random() * 500 - 250;
	sphere.position.z = Math.random() * 500 - 250;
	scene.add( sphere );

	}

	var blueCount = 100;

	for (var i = 0; i < blueCount; i++) {

	var particleSize = Math.random() * 1 -.3;

	var geometry = new THREE.SphereGeometry( particleSize, 32, 32 );
	var material = new THREE.MeshBasicMaterial( {color: 0x23e57a3} ); //white
	//var material = new THREE.MeshBasicMaterial( {color: 0xffff00} ); // yellow
	var sphere = new THREE.Mesh( geometry, material );
	sphere.position.x = Math.random() * 500 - 250;
	sphere.position.y = Math.random() * 500 - 250;
	sphere.position.z = Math.random() * 500 - 250;
	scene.add( sphere );

	}


	var triangleShape = new THREE.Shape()
	.moveTo( 80, 20 )
	.lineTo( 40, 80 )
	.lineTo( 120, 80 )
	.lineTo( 80, 20 ); // close path

		// points
	var points = ( new THREE.PlaneGeometry( 5, 20, 32 ) ).vertices;

		// geometry
	var geometry = new THREE.BufferGeometry();
	var fraction = 0;
	var lineLength;

	// attributes
	numPoints = points.length;
	var positions = new Float32Array( numPoints * 3 ); // 3 vertices per point
	var colors = new Float32Array( numPoints * 3 ); // 3 channels per point
	var lineDistances = new Float32Array( numPoints * 1 ); // 1 value per point

	geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
	geometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );
	geometry.addAttribute( 'lineDistance', new THREE.BufferAttribute( lineDistances, 1 ) );

	// populate
	var color = new THREE.Color();

	for ( var i = 0, index = 0, l = numPoints; i < l; i ++, index += 3 ) {

		positions[ index ] = points[ i ].x;
		positions[ index + 1 ] = points[ i ].y;
		positions[ index + 2 ] = points[ i ].z;

		color.setHSL( i / l, 1.0, 0.5 );

		colors[ index ] = color.r;
		colors[ index   ] = color.g;
		colors[ index + 2 ] = color.b;

		if ( i > 0 ) {

			lineDistances[ i ] = lineDistances[ i - 1 ] + points[ i - 1 ].distanceTo( points[ i ] );

		}

	}

	lineLength = lineDistances[ numPoints - 1 ];

	// material
	var material = new THREE.LineDashedMaterial( {

  	//vertexColors: THREE.VertexColors,
  	dashSize: 3, // to be updated in the render loop
  	gapSize: 1e10 // a big number, so only one dash is rendered

	} );

	// line
	line = new THREE.Line( geometry, material );
	scene.add( line );



	function animate() {
		requestAnimationFrame( animate );
		controls.update();
		fraction = ( fraction + 0.001 ) % 1;
		line.material.dashSize = fraction * lineLength;
		renderer.render( scene, camera );

	}


	animate();

</script>



</body>
</html>